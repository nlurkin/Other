%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[a4paper]{article}

\usepackage{geometry}         % DÃ©finir les marges
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{enumitem}

\title{NA62 RunControl}
\author{Nicolas Lurkin}

\newcommand{\note}[1]{\footnote{TODO: {#1}}}

\begin{document}

\maketitle

\section{Finite State Machine}
The NA62 RunControl is based on a three levels tree-like hierarchy of Finite State Machine (FSM).

Each constituting element of the DAQ (device) is internally modelled as an FSM. Each state of the
FSM is defined by the evaluation of logical expressions depending on a set of parameters that are
provided by the device. The figure \ref{fig:FSM_Device} shows the FSM diagram followed by most of
the devices.

The device nodes are forming the leaves of the tree. The internal nodes are grouping the devices
into logical entities representing subsystems of the experiment. These nodes are also modelled as
FSM, summarizing the states of the devices belonging to this group according to a set of rules.

Finally the root of the tree is an FSM node that represents the global state of the Data Acquisition
by further summarizing the states of all the logical nodes. The figure \ref{fig:FSM_Main} shows the
FSM diagram for this root node which is derived from the device FSM. The possible states are
described below:

\begin{figure}
	\centering
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=\textwidth]{Doc/TEL62FSM.pdf}
		\caption{Generic FSM diagram for the devices.\newline}
		\label{fig:FSM_Device}
	\end{subfigure}
	\begin{subfigure}{0.4\textwidth}
		\includegraphics[width=\textwidth]{Doc/NA62_EN.pdf}
		\caption{FSM diagram of the root node representing the global state of the NA62 DAQ.}
		\label{fig:FSM_Main}
	\end{subfigure}
	\caption{Main Finite State Machine diagrams of the NA62 RunControl.}
\end{figure}

\begin{itemize}
	\item \textbf{IDLE}: This is the initial state after starting or resetting the FSM and the devices.
	\item \textbf{INITIALIZED}: When all the devices have been configured and the DAQ is ready to take
	data.
	\item \textbf{READY}: All the devices are completely ready for data and waiting for triggers. The
	only exception being the trigger processor waiting in a paused state for further command to
	generate the triggers.
	\item \textbf{RUNNING}: The trigger processor is out of the paused state and running.
	\item \textbf{ERROR}: This state can be reached from any other state whenever a problem occurs on
	any device.
\end{itemize}

Each state allows a list of abstract commands that are propagated downward in the hierarchy to
the device nodes where it is transmitted through the network. The list of commands is described
hereafter:

\begin{itemize}
	\item \textbf{INITIALIZE}: Request to initialize all the devices with a specific configuration.
	\item \textbf{START\_RUN}: Request to all the devices to start the run and move in a ready state
	where they are able to take data.
	\item \textbf{ENABLE\_TRIGGER}: Request to the trigger processor to start generating triggers.
	\item \textbf{PAUSE}: Request to the trigger processor to stop generating triggers.
	\item \textbf{END\_RUN}: Request to all devices to stop taking data and end the current run.
	\item \textbf{RESET}: Immediately move to an idle/initialized state, stopping the current run if it
	was ongoing.
\end{itemize}

\section{Interface}
The link between the device nodes modelling a specific device and the hardware itself is
established by DIM\cite{biblio:DIM}\footnote{Distributed Information Management System} that will
take care of transmitting the commands from the RunControl to the device and the state parameters from the
device to the RunControl, along with any other relevant information that should be known by the
RunControl or made available to the shifters.

\subsection{DIM commands/services} \label{sec:DIM}
DIM is working on a client-server model where the same instance can be both server and client.
The server part implements command and service ports. The clients can push commands/requests to
the device via the first type (input). The minimum set of DIM commands to be implemented to
interface with the RunControl is the following:
\begin{enumerate}[label=\textbf{CMD.\arabic*}]
	\item \label{cmd:command} dimServerName/Command (Format: ``C''): For the commands described in
	\ref{sec:commands}.
	\item \label{cmd:fileContent} dimServerName/FileContent (Format: ``C''): For the configuration
	files content according to the procedure described in \ref{sec:configuration}.
	\item \label{cmd:endTransfer} dimServerName/EndTransfer (Format: ``I''): For signalling that the
	last configuration file has been transferred.
\end{enumerate}
The service ports are providing information to the clients connected to the device (output).
With these ports, the RunControl is able to determine the exact state of the hardware,
transmit information to the user and log them in the database. The minimum set of DIM services to
be implemented is the following:
\begin{enumerate}[label=\textbf{SVC.\arabic*}]
	\item \label{svc:state} dimServerName/State (Format: ``I''): For FSM state reporting. If the device
	is internally keeping track of its internal state, this state should be reported in this service. There should
	be a one to one correspondence with the FSM diagram \ref{fig:FSM_Device}. The standard convention
	is shown in Table \ref{table:FSMStates}.
	\begin{table}
		\center
		\begin{tabular}{c|c}
			FSM State & Value\\
			\hline
			IDLE & 0\\
			INITIALIZED & 1\\
			READY & 2\\
			ERROR & Other (-99 reserved)\\
			\hline
		\end{tabular}
		\caption{Mapping between value of service \ref{svc:state} and RunControl device FSM state.}
		\label{table:FSMStates}
	\end{table}
	The use of any other value for the ERROR state allows defining different type of errors identified
	by the error (state) code. See \ref{svc:stateParams} for an alternative if your device does not
	maintain its internal FSM state.
	\item \label{svc:info} dimServerName/Info (Format: ``C''): For transmitting output to the user. This
	service should be the equivalent of stdout when the control software is running in command line. It is only used
	to inform the user currently working on this specific equipment and will not be recorded.
	\item \label{svc:logging} dimServerName/Logging (Format: ``I:1;I:1;C''): For the logging mechanism
	described in \ref{sec:logging}. Contrary to the previous service, this one should only provide important and
	summarized information that will be stored in the offline database to keep track for future records
	of important problems that happened during the run.
	\item \label{svc:waiting} dimServerName/Waiting (Format: ``I''): To notify the RunControl that the
	processing of the current configuration file is finished.
	\item \label{svc:config} dimServerName/Config (Format: ``C''): To report back to the RunControl the
	current values of the configuration parameters.
\end{enumerate}

For all the commands/services described in this document, dimServerName is a unique name identifying
the device.

The client part can connect to a server's command port to send it commands or to a server's
service port to receive data from it. The RunControl is acting as a client connected to the device's
server whose minimum interface is described above, but is also acting as a server, providing different informations:
\begin{itemize}
	\item RunControl/RunNumber (Format: ``I''): Run number of the current run.
	\item RunControl/BurstNumber (Format: ``I''): Number of bursts in the current run.
	\item RunControl/EnabledDetectors (Format: ``C''): List of enabled detectors for the current run
	and number of data source for each detector. The string has the format\\ 
	\mbox{``DetID:NSource,DetID:NSource,\ldots''} where DetID is the detector ID in hexadecimal format
	(0x18) defined in \cite{biblio:TDAQNote} and NSource is the number of data source. This
	service is primarily intended for the PC farm.
\end{itemize}

\subsection{RunControl commands}\label{sec:commands}

As the RunControl is not aware of the internal operation of any device, the commands are very
generic and the device is expected to understand them and execute the appropriate sequence of actions
specific to itself. After the execution of the associated action the devices should answer back to
the RunControl, notifying the success or failure of the action by updating/refreshing its state
parameters on service \ref{svc:state} (or the alternative \ref{svc:stateParams}).

The commands are sent to the command port \ref{cmd:command} as a string. The first token of the
string is the command name and the following tokens are the command arguments, if any. The minimum
set of commands to be understood and implemented is the following:
\begin{itemize}
	\item initialize
	\item startrun runNumber
	\item endrun
	\item resetstate
\end{itemize}

After receiving any of these commands, the device should be ready to receive an eventual
configuration file according to the procedure described in section \ref{sec:configuration}.

\section{Configuration}\label{sec:configuration}
The configuration mechanism of the RunControl will take advantage of the existing recipe mechanism
of the JCOP\cite{biblio:JCOP} framework: a database contains an ensemble of fields and a list of
recipes (configuration modes). Specific values of the field are associated to each recipe. At
configuration time a prompt will ask the user to select a recipe to load.

Again, in order to hide the internals of the devices from the RunControl, the actual configuration
parameters/values are contained in a configuration file. The content of the files will be written in
the JCOP database and associated to recipes. When loading a recipe, the associated files content
will be transmitted integrally to the device that will again be responsible to decode it and apply
the values.

A tool will be available to dump configuration files into the database and an ``on-line'' editor will
also be provided to modify/write files directly in the database. The entries in the database can be
independent files or different versions of a same file and will be identified by a name and will
be associated to one or several tags relating it to recipes.

The configuration files can be incremental: for each recipe, a list of files can be sent to the
device. The first one would contain ``default'' values, values that are valid for different type of
runs, parameters that rarely change. The following files would contain parameters that have a
higher changing rate. The files will be send to the device sequentially and the value applied for a
specific parameter should always be the one specified in the last file (values in the latest file
are overwriting the values in the earliest ones). The default file could also be used when no file
is specified for the given recipe or when resetting the device.

The file transfer mechanism will work as described hereafter:
\begin{enumerate}
	\item \label{transf:start} After sending one of the commands described in \ref{sec:commands}, the
	RunControl will send the content of the first configuration file as a string on the command slot \ref{cmd:command}. If
	no file is specified, the RunControl will move directly to point \ref{transf:end} of this
	procedure.
	\item Upon reception of the file content, the device sets the value of \ref{svc:waiting} to 0 and
	start processing the configuration file (the details are left to the specific device
	implementation).
	\item \label{transf:wait} The RunControl wait until the device notifies that the file has been
	entirely processed and is waiting for further instructions by setting the value of
	\ref{svc:waiting} to 1.
	\item The RunControl repeats the points \ref{transf:start} and \ref{transf:wait} for the next
	configuration files until the last one has been processed.
	\item \label{transf:end} Once the entire configuration has been applied the RunControl sends 1 on
	\ref{cmd:endTransfer} to warn the device that there are no more configuration files.
	\item The device is now supposed to report back the current configuration. It will generate a file
	containing all the current parameters value, possibly in the same format as the configuration
	file. The file is transmitted to the RunControl by publishing it on the service port
	\ref{svc:config} and is stored in the offline database. Two possibilities are given to the
	subsystem:
	\begin{itemize}
		\item When applying the configuration files, keeping track of the real value of each parameter
		(the one that has been applied) and report this list of values, trusting that everything went
		well and that these values were effectively loaded in the hardware.
		\item Request the hardware for the actual value of each parameter and report this list of true
		values.
	\end{itemize}
	\item Finally the device updates its state parameters \ref{svc:state} or \ref{svc:stateParams},
	indicating the end of the configuration procedure. 
\end{enumerate}
At any point of the procedure, if something goes wrong or an anomaly is detected by the device, it
can move to an ERROR state that will interrupt the procedure. 

\section{Logging}\label{sec:logging}
The RunControl will be connected to three different databases: the configuration database containing
the recipes and the configuration files, the online database storing number of information related
to the run and the instantaneous state of the data taking, PC farm, \ldots. And finally the offline
database that will contain the subset of the online values that are relevant to future analysis and
the configuration for each run.

In addition to the run values logging, there will be a centralized device logging. This logging will
be displayed in the control room and recorded in the database. Every device will implement the
service port \ref{svc:logging} providing the source id, a severity code and the text message itself.

\section{Alternative/Additional functionalities}
Alternative or additional functionalities can be provided by or to the device. Any of the
possibilities listed, or not, hereafter as well as anything not following the standards described
up to this point are to be discussed and agreed with the RunControl developers well in advance.

Examples of alternative or additional services are given below and are taken from devices already
integrated in the RunControl:
\begin{enumerate}[label=\textbf{ASVC.\arabic*}]
	\item \label{svc:stateParams} dimServerName/paramName: The single \ref{svc:state}
	service is reporting the FSM state that is internally maintained and has to comply with the
	convention outlined in Table \ref{table:FSMStates}. An alternative is to provide a series of
	parameters through as much service ports. The RunControl can assemble these values through logical
	expression to determine one of the states depicted in figure \ref{fig:FSM_Device}. For the rest,
	these ports have to follow the same rules as the \ref{svc:state} one.
	\item dimServerName/TriggerNumber (Format: ``X''): From the L0TP. Number of triggers generated
	during the current burst.
\end{enumerate}

Examples of additional commands are given below and are taken from devices already integrated in
the RunControl:
\begin{enumerate}[label=\textbf{ACMD.\arabic*}]
	\item dimServerName/SendTrigger (Format: ``X''): From the L0TP. Request to generate a certain
	number of triggers during next burst.
\end{enumerate}


\thebibliography{}

\bibitem{biblio:DIM}{http://dim.web.cern.ch/dim/}
\bibitem{biblio:JCOP}{https://j2eeps.cern.ch/wikis/display/EN/JCOP+Framework}
\bibitem{biblio:TDAQNote}{M.S. Sozzi et al., ``NA62 online software and TDAQ interface.'', NA62
Note NA62-11-02, 2011}
\end{document}
